<!DOCTYPE html>
<html>

<head>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="keywords" content="footer, address, phone, icons" />

	<title>User guide to programming Arabesque</title>

	<link rel="stylesheet" href="assets/css/demo.css">
	<link rel="stylesheet" href="assets/css/footer-distributed-with-address-and-phones.css">
	<link rel="stylesheet" href="assets/css/header-basic.css">
	<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css">
	<link href="http://fonts.googleapis.com/css?family=Cookie" rel="stylesheet" type="text/css">
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/bootstrap-responsive.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/pilcrow.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/hljs-github.min.css"/>
    <link type="text/css" rel="stylesheet" href="assets/css/github-markdown.css">

</head>

	<body>
		<header class="header-basic">

			<div class="header-limiter">

				<h1><a href="index.html"><img src="imgs/arabesque-logo-small.png" alt=""> Arabesque</a></h1>

				<nav>
					<a href="index.html">Home</a>
					<a href="user_guide.html">User Guide</a> <!-- class="selected" -->
					<a href="download.html">Download</a>
					<a href="about.html">About</a>
				</nav>
			</div>

		</header>

		<!-- The content of your page would go here. -->
<div class="container-fluid">
    <div class="row-fluid">
      <div class="span3"><ul class="nav nav-list">
    <li><a href="#programming-in-arabesque">Programming in Arabesque</a></li>
    <li><a href="#high-level-programming-api">High-Level Programming API</a></li>
    <li><a href="#finding-cliques">Finding Cliques</a></li>
    <li><a href="#counting-motif">Counting Motif</a></li>
    <li><a href="#frequent-subgraph-mining">Frequent Subgraph Mining</a></li>
    <li><a href="#how-to-run-an-arabesque-job">How to Run an Arabesque Job</a></li>
    <li><a href="#requirements-for-input-graph">Requirements for Input Graph</a></li>
</ul>
      </div>
      <article class="span9 markdown-body">
      <!-- <div class="span9 markdown-body"> --><h1 id="programming-in-arabesque"><a class="header-link" href="#programming-in-arabesque"></a>Programming in Arabesque</h1>
<p>Arabesque simplifies the programming of Graph Mining Problems as presented in our <a href="http://sigops.org/sosp/sosp15/current/2015-Monterey/printable/093-teixeira.pdf">paper</a>, that describes the system and provides a comprehensive introduction to the concepts that we describe below.</p>
<p>We show how Arabesque can be used to solve three fundamental problems in Graph Mining. Finding cliques, counting motifs and frequent subgraph mining. We chose these problems because they represent different classes of graph mining problems. Finding cliques is an example of dense subgraph mining, and allows one to prune the embeddings using local information. Counting motifs requires exhaustive graph exploration up to some maximum size.  Frequent subgraph mining is an example of explore-and-prune problems, where only embeddings corresponding to a frequent pattern need to be further explored.  We discuss these problems below in more detail. </p>
<h2 id="high-level-programming-api"><a class="header-link" href="#high-level-programming-api"></a>High-Level Programming API</h2>
<p>For Reference we have the high-level API in the simple case where we require no aggregation (first two algorithms).
<img src="imgs/TLE.png" alt="TLE paradigm:"></p>
<p>For the third case, we have the aggregation based API.
<img src="imgs/Agg.png" alt="Agg paradigm:"></p>
<p>An aggregator in Arabesque has several components:</p>
<ul class="list">
<li>Key Class</li>
<li>Value Class</li>
<li>Reduction function (f(V, V) -&gt; V)</li>
<li>(Optional) Function to execute at the end of the aggregation to remove stuff you’re not interested in (it doesn’t aggregate anything)</li>
</ul>
<h2 id="finding-cliques"><a class="header-link" href="#finding-cliques"></a>Finding Cliques</h2>
<p>Finding <a href="https://en.wikipedia.org/wiki/Clique_problem">cliques</a> has many variations. Here, we present the variation of finding cliques of a maximum size. Following, we have the implementation in Arabesque. </p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CliqueComputation</span> 
            <span class="hljs-keyword">extends</span> <span class="hljs-title">VertexInducedComputation</span>&lt;<span class="hljs-title">VertexInducedEmbedding</span>&gt; </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAXSIZE = <span class="hljs-string">"arabesque.clique.maxsize"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXSIZE_DEFAULT = <span class="hljs-number">4</span>;

    <span class="hljs-keyword">int</span> maxsize;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.init();
        maxsize = Configuration.get().getInteger(MAXSIZE, MAXSIZE_DEFAULT);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">filter</span><span class="hljs-params">(VertexInducedEmbedding embedding)</span> </span>{
        <span class="hljs-keyword">return</span> isClique(embedding);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isClique</span><span class="hljs-params">(VertexInducedEmbedding embedding)</span> </span>{
        <span class="hljs-keyword">return</span> embedding.getNumEdgesAddedWithExpansion() 
                == embedding.getNumVertices() - <span class="hljs-number">1</span>;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(VertexInducedEmbedding embedding)</span> </span>{
        <span class="hljs-keyword">if</span> (embedding.getNumWords() == maxsize) {
            output(embedding);
        }
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldExpand</span><span class="hljs-params">(VertexInducedEmbedding newEmbedding)</span> </span>{
        <span class="hljs-keyword">return</span> newEmbedding.getNumWords() &lt; maxsize;
    }

}</code></pre><p>In Arabesque, the user must define the Computation class for the problem at hand. In this particular case, we have defined the class <strong>CliqueComputation</strong> that extends the <strong>VertexInducedComputation</strong>, which dictates that the exploration that Arabesque will perform is Vertex Induced. As we explained earlier, this exploration extends an embedding by adding all edges of a vertex.</p>
<p>To solve the problem and control the exploration the user defines two main functions. The <strong>filter</strong> function that decides whether the passed embedding is a valid clique and thus it should be further expanded and processed, and the <strong>process</strong> that dictates what to do with the embeddings that passed the filter function. In this particular problem, we only want to output the embeddings. Note, that the complexity of the exploration and the required checks for avoiding redudant work, and the canonicality checks are completely transparent to the end-user. Properties like anti-monotonicity are trivial to show that hold for this filter function. </p>
<p>For performance reasons, the <strong>filter</strong> is implemented in an incremental way. An embedding consists of two parts, a parent embedding that had passed all the tests in the previous exploration step, and a current candidate extension. Thus we can efficiently implement the filter function by only considering whether the candidate extension vertex connects to all previous vertices in the parent embedding. This can be done very easily, by getting the number of new edges added to this embedding <em>getNumEdgesAddedWithExpansion()</em> and checking if this number is equal to the number of vertices in the parent embedding which by default is one less than the current embedding.</p>
<p>To produce the output, we simply check whether we have reached the size of cliques we are interested in. If we have, we simlpy output the embedding.</p>
<p>To avoid going to deeper depths than the one we want to discover, the user can override the optional <strong>shouldExpand</strong> function that checks whether we need to further expand the embedding and thus continue the exploration. By default, this function returns true, and by overriding it we can stop the processing faster. </p>
<h2 id="counting-motif"><a class="header-link" href="#counting-motif"></a>Counting Motif</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Network_motif">motif</a> is defined as a connected pattern of vertex induced embeddings that exists in an input graph. Further, a set of motifs is required to be non-isomorphic, i.e., there should obviously be no duplicate patterns. In motif mining, the input graph is assumed to be unlabeled, and there is no minimum frequency threshold; rather the goal is to extract all motifs that occur in the graph along with their frequency distribution. Since this task is inherently exponential, the motifs are typically restricted to patterns of order (i.e., number of vertices) at most k. For example, for k = 3 we have two possible motifs: a chain where ends are not connected and a (complete) triangle. Following, we have the Motif implementation in Arabesque.</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MotifComputation</span> 
                <span class="hljs-keyword">extends</span> <span class="hljs-title">VertexInducedComputation</span>&lt;<span class="hljs-title">VertexInducedEmbedding</span>&gt; </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAXSIZE = <span class="hljs-string">"arabesque.motif.maxsize"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXSIZE_DEFAULT = <span class="hljs-number">4</span>;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LongWritable reusableLongWritableUnit = <span class="hljs-keyword">new</span> LongWritable(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxsize;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.init();
        maxsize = Configuration.get().getInteger(MAXSIZE, MAXSIZE_DEFAULT);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initAggregations</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.initAggregations();

        Configuration conf = Configuration.get();

        conf.registerOutputAggregation(conf.getPatternClass(), 
                                           LongWritable.class, 
                                       <span class="hljs-keyword">new</span> LongSumReduction());
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(VertexInducedEmbedding embedding)</span> </span>{
        <span class="hljs-keyword">if</span> (embedding.getNumWords() == maxsize) {
            mapOutput(embedding.getPattern(), reusableLongWritableUnit);
        }
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldExpand</span><span class="hljs-params">(VertexInducedEmbedding newEmbedding)</span> </span>{
        <span class="hljs-keyword">return</span> newEmbedding.getNumWords() &lt; maxsize;
    }
}</code></pre><p>The Computation class, <strong>MotifComputation</strong>, extends the <strong>VertexInducedComputation</strong>, which dictates that the exploration that Arabesque will perform is Vertex Induced in a similar way to finding cliques.</p>
<p>For counting Motifs, we are interested in all possible variations of the embeddings and thus we don&#39;t need to implement a special filter function. The default filter function returns true and is sufficient for this problem. For the process implementation, we need to compute for every embedding the pattern it corresponds (motif for this problem), and then group it over all embeddings to compute the frequencies of the motifs. In Arabesque, this aggregation is performed using the <em>output aggregators</em>, which are similar to functionality to Giraph&#39;s Aggregators, and allow to compute aggregate statistics on a pattern level or any arbitrary value. In the process function, we simlpy increase by one the pattern that this empedding corresponds. Before using the output Aggregators, we need to initialize them, something done in the <strong>initAggregations</strong> function. In this function, we register the aggregator and we define as parameters the type of aggregation to perform. For motifs, a simple sum aggregation is sufficient.</p>
<p>The shouldExpand similarly to the Clique computation, terminates the expansion when the desired depth has been reached.</p>
<h2 id="frequent-subgraph-mining"><a class="header-link" href="#frequent-subgraph-mining"></a>Frequent Subgraph Mining</h2>
<p>The task of frequent subgraph mining (FSM), i.e., finding those subgraphs (or patterns, in our terminology) that occur a minimum number of times in the input graph. The occurrences are counted using some anti-monotonic function on the set of its embeddings. The FSM task is to mine all frequent subgraph patterns from a single graph.</p>
<p>In frequent subgraph mining, we use aggregation to calculate the support function required to prune the infrequent patterns. The support metric is based on the notion of domain, which is defined as the set of distinct mappings between a vertex in a pattern and the matching vertices in any automorphism of an embedding. The process function invokes map to send the domains of embedding to the reducer responsible for the pattern of this embedding. The function reduce merges all domains: the merged domain of a vertex in a pattern is the union of all its aggregated mappings. The aggregationFilter function reads the merged domains of p using readAggregate and computes the support, which is the minimum size of the domain of any vertex in the pattern. It then filters out embeddings for patterns that do not have enough support. Finally, the aggregationProcess function outputs all the embeddings having a frequent pattern (those that survive the aggregation-filter).</p>
<p>The implementation in Arabesque is the following.</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSMComputation</span> 
        <span class="hljs-keyword">extends</span> <span class="hljs-title">EdgeInducedComputation</span>&lt;<span class="hljs-title">EdgeInducedEmbedding</span>&gt; </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CONF_SUPPORT = <span class="hljs-string">"arabesque.fsm.support"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONF_SUPPORT_DEFAULT = <span class="hljs-number">1000</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CONF_MAXSIZE = <span class="hljs-string">"arabesque.fsm.maxsize"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONF_MAXSIZE_DEFAULT = -<span class="hljs-number">1</span>;

    <span class="hljs-keyword">private</span> DomainSupport reusableDomainSupport;

    <span class="hljs-keyword">private</span> AggregationStorage&lt;Pattern, DomainSupport&gt; previousStepAggregation;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> support;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.init();

        Configuration conf = Configuration.get();

        support = conf.getInteger(CONF_SUPPORT, CONF_SUPPORT_DEFAULT);
        maxSize = conf.getInteger(CONF_MAXSIZE, CONF_MAXSIZE_DEFAULT);

        reusableDomainSupport = <span class="hljs-keyword">new</span> DomainSupport(support);

        previousStepAggregation = readAggregation();
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initAggregations</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.initAggregations();

        Configuration conf = Configuration.get();

        conf.registerInterStepAggregation(conf.getPatternClass(), 
                                        DomainSupport.class,
                                    <span class="hljs-keyword">new</span> DomainSupportReducer(), 
                                    <span class="hljs-keyword">new</span> DomainSupportEndAggregationFunction());
    }

    <span class="hljs-comment">// Previous Step embeddings</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">aggregationFilter</span><span class="hljs-params">(EdgeInducedEmbedding previousStepEmbedding)</span> </span>{
        <span class="hljs-comment">// Using the DomainSupportEndAggregationFunction, we </span>
        <span class="hljs-comment">// removed all mappings for non-frequent patterns. </span>
        <span class="hljs-comment">// So we simply have to check if the mapping has</span>
        <span class="hljs-comment">// the pattern for the corresponding key</span>
        <span class="hljs-keyword">return</span> previousStepAggregation.containsKey(previousStepEmbedding.getPattern());
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aggregationProcess</span><span class="hljs-params">(EdgeInducedEmbedding previousStepEmbedding)</span> </span>{
        output(previousStepEmbedding);
    }

    <span class="hljs-comment">// Current step embeddings </span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(EdgeInducedEmbedding embedding)</span> </span>{
        reusableDomainSupport.setFromEmbedding(embedding);
        map(embedding.getPattern(), reusableDomainSupport);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldExpand</span><span class="hljs-params">(EdgeInducedEmbedding newEmbedding)</span> </span>{
        <span class="hljs-keyword">return</span> maxSize &lt; <span class="hljs-number">0</span> || newEmbedding.getNumWords() &lt; maxSize;
    }
}</code></pre><p>The Computation class <strong>FSMComputation</strong> extends the EdgeInducedComputation class, which determines that the exploration is edge induced, a different exploration strategy to the previous two Applications. As in the motifs problem, we don&#39;t have to define a filter function, since we want to exhaustively evaluate all different possibilities. </p>
<p>The pruning functionality can only be performed in the next superstep, thus it requires a different form of aggregation compared to the output Aggregators we used earlier. The special aggregators that we use are called <em>inter step aggregators</em>, and need to be initialized in the initAggregations() function. When interStepAggregator are used, before the actual computation of the embeddings, we can pre-filter the embeddings of the previous superstep using a new filtering step called aggregationFilter. The aggregationFilter checks whether the pattern associated with an embedding is a frequent one or not. If the pattern is frequent, then this embedding is allowed to proceed with the expansions and further be processed in this superstep. Otherwise the embedding is rejected. Similarly to the filter, we provide an aggregationProcess function that is called after the aggregationFilter is true, that allows for processing the embedding, for instance, by written to the output.</p>
<p>For efficiency reasons, we allow the interStepAggregator after aggregation has finished to be cleaned. This is an optional parameter that can work on the aggregated value, before the value is propagated for the next superstep. In our case, this is performed by the <strong>DomainSupportEndAggregationFunction</strong> which prunes at the end of the superstep the domains that are not frequent.</p>
<p>The process function for FSM is used first to create the domain for the embedding, and then aggregate the domains based on the pattern (map function).</p>
<p>If required to control the depth of the exploration, the user can define the optional shouldExpand function similarly to the previous applications.</p>
<p>One last difference to the previous applications is that the output can only be generated after the superstep finishes. Thus to output the processing, we take the same approach that Giraph uses to use the Master Computation functionality that is called at the beginning of the superstep, where the results of the inter step aggregation are available. The <strong>internalCompute</strong>, simply reads the aggregated value and prints the information.</p>
<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSMMasterComputation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MasterComputation</span> </span>{
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">internalCompute</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.internalCompute();

        AggregationStorage&lt;Pattern, DomainSupport&gt; aggregationStorage = getAggregatedValue(Configuration.AGG_INTERSTEP);

        <span class="hljs-keyword">if</span> (aggregationStorage.getNumberMappings() &gt; <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"Frequent patterns:"</span>);

            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (Pattern pattern : aggregationStorage.getKeys()) {
                System.out.println(i + <span class="hljs-string">": "</span> + pattern);
                ++i;
            }
        }
        <span class="hljs-comment">// If frequent patterns is empty and superstep &gt; 0, halt</span>
        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(getSuperstep()</span> &gt; 0) </span>{
            haltComputation();
        }
    }
}</code></pre><h1 id="how-to-run-an-arabesque-job"><a class="header-link" href="#how-to-run-an-arabesque-job"></a>How to Run an Arabesque Job</h1>
<p>To configure an Arabesque job, we use YAMLs files. We have a cluster.yaml file that defines the parameters of the servers, for instance number of workers, threads etc. The application yaml file specifies the problem to run and applicable parameters.</p>
<p>An example of the cluster.yaml file:</p>
<pre class="hljs"><code><span class="hljs-attribute">num_workers</span>: <span class="hljs-string">2</span>
<span class="hljs-attribute">num_compute_threads</span>: <span class="hljs-string">32</span>
<span class="hljs-attribute">output_active</span>: <span class="hljs-string">no</span>

<span class="groovy"># Giraph configuration
giraph.<span class="hljs-string">nettyClientThreads:</span> <span class="hljs-number">32</span>
giraph.<span class="hljs-string">nettyServerThreads:</span> <span class="hljs-number">32</span>
giraph.<span class="hljs-string">nettyClientExecutionThreads:</span> <span class="hljs-number">32</span>
giraph.<span class="hljs-string">channelsPerServer:</span> <span class="hljs-number">4</span>
giraph.<span class="hljs-string">useBigDataIOForMessages:</span> <span class="hljs-literal">true</span>
giraph.<span class="hljs-string">useNettyPooledAllocator:</span> <span class="hljs-literal">true</span>
giraph.<span class="hljs-string">useNettyDirectMemory:</span> <span class="hljs-literal">true</span>
giraph.<span class="hljs-string">nettyRequestEncoderBufferSize:</span> <span class="hljs-number">1048576</span></span></code></pre><p>Configuration for Cliques:</p>
<pre class="hljs"><code><span class="hljs-label">computation:</span> io.arabesque.examples.clique.CliqueComputation
<span class="hljs-label">input_graph_path:</span> mico-qanat-sortedByDegree-sameLabel.txt
<span class="hljs-preprocessor">#communication_strategy: cache</span>

<span class="hljs-preprocessor"># Custom parameters</span>
<span class="hljs-label">arabesque.clique.maxsize:</span> <span class="hljs-number">4</span></code></pre><p>Configuration for Motifs:</p>
<pre class="hljs"><code><span class="hljs-label">computation:</span> io.arabesque.examples.motif.MotifComputation
<span class="hljs-label">input_graph_path:</span> mico-qanat-sortedByDegree-sameLabel.txt
<span class="hljs-preprocessor">#communication_strategy: cache</span>

<span class="hljs-preprocessor"># Custom parameters</span>
<span class="hljs-label">arabesque.motif.maxsize:</span> <span class="hljs-number">4</span></code></pre><p>Configuration for Frequent Subgraph Mining:</p>
<pre class="hljs"><code><span class="hljs-label">computation:</span> io.arabesque.examples.fsm.FSMComputation
<span class="hljs-label">master_computation:</span> io.arabesque.examples.fsm.FSMMasterComputation
<span class="hljs-label">input_graph_path:</span> citeseer-qanat-sortedByDegree.txt
<span class="hljs-preprocessor">#communication_strategy: cache</span>

<span class="hljs-preprocessor"># Custom parameters</span>
<span class="hljs-label">arabesque.fsm.support:</span> <span class="hljs-number">300</span>
<span class="hljs-preprocessor">#arabesque.fsm.maxsize: 7</span>
<span class="hljs-label">arabesque.fsm.num_agg_splits:</span> <span class="hljs-number">10</span></code></pre><p>To actual submit an Arabesque job, for instance Cliques, you simply run</p>
<pre class="hljs"><code>./run_arabesque.sh cluster.yaml cliques.yaml</code></pre><h2 id="requirements-for-input-graph"><a class="header-link" href="#requirements-for-input-graph"></a>Requirements for Input Graph</h2>
<p>The graph should have sequential ids assigned to vertices. </p>
      </article>
    </div>
  </div>

		<div class="footer-distributed">
			<div class="footer-left">

				<h3><span>Arabesque</span></h3>
				<p class="footer-company-name">Arabesque.io &copy; 2015</p>
			</div>

			<div class="footer-center">

				<div>
					<i class="fa fa-map-marker"></i>
					<p><span>Tornado Tower</span> Doha, Qatar</p>
				</div>

				<div>
					<i class="fa fa-phone"></i>
					<p>+974 5528 3942</p>
				</div>

				<div>
					<i class="fa fa-envelope"></i>
					<p><a href="mailto:afonseca@qf.org.qa">Alexander :-)</a></p>
				</div>

			</div>

			<div class="footer-right">

				<p class="footer-company-about">
					<span>About Arabesque.io</span>
					Arabesque.io is an open source project of Qatar Computing Research Institute, HBKU.
				</p>

				<div class="footer-icons">

					<!-- <a href="#"><i class="fa fa-facebook"></i></a> -->
					<a href="#"><i class="fa fa-twitter"></i></a>
					<!-- <a href="#"><i class="fa fa-linkedin"></i></a> -->
					<a href="https://github.com/Qatar-Computing-Research-Institute/Arabesque"><i class="fa fa-github"></i></a>

				</div>

			</div>
		</div>

	</body>

</html>
